package com.msharp.sharding.jdbc.sphere.connection;

import com.msharp.sharding.jdbc.sphere.datasource.MasterSlaveDataSource;
import com.msharp.sharding.jdbc.sphere.statement.MasterSlavePreparedStatement;
import com.msharp.sharding.jdbc.sphere.statement.MasterSlaveStatement;
import io.shardingsphere.shardingjdbc.jdbc.adapter.AbstractConnectionAdapter;
import io.shardingsphere.transaction.api.TransactionType;

import javax.sql.DataSource;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;


/**
 * MasterSlaveConnection
 *
 * @author mwup
 * @version 1.0
 * @created 2019/03/01 13:51
 **/
public class MasterSlaveConnection extends AbstractConnectionAdapter {

    private final MasterSlaveDataSource masterSlaveDataSource;

    private final Map<String, DataSource> dataSourceMap;

    public MasterSlaveConnection(final MasterSlaveDataSource masterSlaveDataSource, final Map<String, DataSource> dataSourceMap) {
        this(masterSlaveDataSource, dataSourceMap, TransactionType.LOCAL);
    }

    public MasterSlaveConnection(final MasterSlaveDataSource masterSlaveDataSource, final Map<String, DataSource> dataSourceMap, final TransactionType transactionType) {
        super(transactionType);
        this.masterSlaveDataSource = masterSlaveDataSource;
        this.dataSourceMap = dataSourceMap;
    }

    @Override
    public DatabaseMetaData getMetaData() {
        return masterSlaveDataSource.getDatabaseMetaData();
    }

    @Override
    public Statement createStatement() {
        return new MasterSlaveStatement(this);
    }

    @Override
    public Statement createStatement(final int resultSetType, final int resultSetConcurrency) {
        return new MasterSlaveStatement(this, resultSetType, resultSetConcurrency);
    }

    @Override
    public Statement createStatement(final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        return new MasterSlaveStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    @Override
    public PreparedStatement prepareStatement(final String sql) throws SQLException {
        return new MasterSlavePreparedStatement(this, sql);
    }

    @Override
    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        return new MasterSlavePreparedStatement(this, sql, resultSetType, resultSetConcurrency);
    }

    @Override
    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        return new MasterSlavePreparedStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    @Override
    public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
        return new MasterSlavePreparedStatement(this, sql, autoGeneratedKeys);
    }

    @Override
    public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
        return new MasterSlavePreparedStatement(this, sql, columnIndexes);
    }

    @Override
    public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
        return new MasterSlavePreparedStatement(this, sql, columnNames);
    }

    @Override
    protected Map<String, DataSource> getDataSourceMap() {
        return dataSourceMap;
    }

    public MasterSlaveDataSource getMasterSlaveDataSource() {
        return masterSlaveDataSource;
    }
}